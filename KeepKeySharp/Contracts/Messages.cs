// Classes and structures being serialized

// Generated by ProtocolBuffer
// - a pure c# code generation implementation of protocol buffers
// Report bugs to: https://silentorbit.com/protobuf/

// DO NOT EDIT
// This file will be overwritten when CodeGenerator is run.
// To make custom modifications, edit the .proto file and add //:external before the message line
// then write the code and the changes in a separate file.
using System;
using System.Collections.Generic;

namespace KeepKeySharp.Contracts
{
    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing address for various coin types (BTC, LTC, and etc).</para>
    /// <para> * @used in ExchangeResponse</para>
    /// <para></para>
    /// </summary>
    public partial class ExchangeAddress
    {
        public string CoinType { get; set; }

        public string Address { get; set; }

        public string DestTag { get; set; }

        public string RsAddress { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing exchange response version 2</para>
    /// <para></para>
    /// </summary>
    public partial class ExchangeResponseV2
    {
        public global::KeepKeySharp.Contracts.ExchangeAddress DepositAddress { get; set; }

        public byte[] DepositAmount { get; set; }

        public long? Expiration { get; set; }

        public byte[] QuotedRate { get; set; }

        public global::KeepKeySharp.Contracts.ExchangeAddress WithdrawalAddress { get; set; }

        public byte[] WithdrawalAmount { get; set; }

        public global::KeepKeySharp.Contracts.ExchangeAddress ReturnAddress { get; set; }

        public byte[] ApiKey { get; set; }

        public byte[] MinerFee { get; set; }

        public byte[] OrderId { get; set; }

    }

    public partial class SignedExchangeResponse
    {
        public global::KeepKeySharp.Contracts.ExchangeResponse Response { get; set; }

        /// <summary> deprecated - latest firmware version throws error if this field is used</summary>
        public byte[] Signature { get; set; }

        public global::KeepKeySharp.Contracts.ExchangeResponseV2 ResponseV2 { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing exchange response version 1 (deprecated)</para>
    /// <para></para>
    /// </summary>
    public partial class ExchangeResponse
    {
        public global::KeepKeySharp.Contracts.ExchangeAddress DepositAddress { get; set; }

        public ulong? DepositAmount { get; set; }

        public long? Expiration { get; set; }

        public ulong? QuotedRate { get; set; }

        public global::KeepKeySharp.Contracts.ExchangeAddress WithdrawalAddress { get; set; }

        public ulong? WithdrawalAmount { get; set; }

        public global::KeepKeySharp.Contracts.ExchangeAddress ReturnAddress { get; set; }

        public byte[] ApiKey { get; set; }

        public ulong? MinerFee { get; set; }

        public byte[] OrderId { get; set; }

    }

    /// <summary>
    /// <para> Basic messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Reset device to default state and ask for device details</para>
    /// <para> * @next Features</para>
    /// <para></para>
    /// </summary>
    public partial class Initialize
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask for device details (no device reset)</para>
    /// <para> * @next Features</para>
    /// <para></para>
    /// </summary>
    public partial class GetFeatures
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Reports various information about the device</para>
    /// <para> * @prev Initialize</para>
    /// <para> * @prev GetFeatures</para>
    /// <para></para>
    /// </summary>
    public partial class Features
    {
        public string Vendor { get; set; }

        /// <summary> name of the manufacturer, e.g. "bitcointrezor.com"</summary>
        public uint? MajorVersion { get; set; }

        /// <summary> major version of the device, e.g. 1</summary>
        public uint? MinorVersion { get; set; }

        /// <summary> minor version of the device, e.g. 0</summary>
        public uint? PatchVersion { get; set; }

        /// <summary> patch version of the device, e.g. 0</summary>
        public bool? BootloaderMode { get; set; }

        /// <summary> is device in bootloader mode?</summary>
        public string DeviceId { get; set; }

        /// <summary> device's unique identifier</summary>
        public bool? PinProtection { get; set; }

        /// <summary> is device protected by PIN?</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> is node/mnemonic encrypted using passphrase?</summary>
        public string Language { get; set; }

        /// <summary> device language</summary>
        public string Label { get; set; }

        /// <summary> device description label</summary>
        public List<global::KeepKeySharp.Contracts.CoinType> Coins { get; set; }

        /// <summary> supported coins</summary>
        public bool? Initialized { get; set; }

        /// <summary> does device contain seed?</summary>
        public byte[] Revision { get; set; }

        /// <summary> SCM revision of firmware</summary>
        public byte[] BootloaderHash { get; set; }

        /// <summary> hash of the bootloader</summary>
        public bool? Imported { get; set; }

        /// <summary> was storage imported from an external source?</summary>
        public bool? PinCached { get; set; }

        /// <summary> is PIN already cached in session?</summary>
        public bool? PassphraseCached { get; set; }

        /// <summary> is passphrase already cached in session?</summary>
        public List<global::KeepKeySharp.Contracts.PolicyType> Policies { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: clear session (removes cached PIN, passphrase, etc).</para>
    /// <para> * @next Success</para>
    /// <para></para>
    /// </summary>
    public partial class ClearSession
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: change language and/or label of the device</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para> * @next ButtonRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para></para>
    /// </summary>
    public partial class ApplySettings
    {
        public string Language { get; set; }

        public string Label { get; set; }

        public bool? UsePassphrase { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Starts workflow for setting/changing/removing the PIN</para>
    /// <para> * @next ButtonRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para></para>
    /// </summary>
    public partial class ChangePin
    {
        public bool? Remove { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Test if the device is alive, device sends back the message in Success response</para>
    /// <para> * @next Success</para>
    /// <para></para>
    /// </summary>
    public partial class Ping
    {
        public string Message { get; set; }

        /// <summary> message to send back in Success message</summary>
        public bool? ButtonProtection { get; set; }

        /// <summary> ask for button press</summary>
        public bool? PinProtection { get; set; }

        /// <summary> ask for PIN if set in device</summary>
        public bool? PassphraseProtection { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Success of the previous request</para>
    /// <para></para>
    /// </summary>
    public partial class Success
    {
        public string Message { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Failure of the previous request</para>
    /// <para></para>
    /// </summary>
    public partial class Failure
    {
        public global::KeepKeySharp.Contracts.FailureType? Code { get; set; }

        /// <summary> computer-readable definition of the error state</summary>
        public string Message { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device is waiting for HW button press.</para>
    /// <para> * @next ButtonAck</para>
    /// <para> * @next Cancel</para>
    /// <para></para>
    /// </summary>
    public partial class ButtonRequest
    {
        public global::KeepKeySharp.Contracts.ButtonRequestType? Code { get; set; }

        public string Data { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Computer agrees to wait for HW button press</para>
    /// <para> * @prev ButtonRequest</para>
    /// <para></para>
    /// </summary>
    public partial class ButtonAck
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device is asking computer to show PIN matrix and awaits PIN encoded using this matrix scheme</para>
    /// <para> * @next PinMatrixAck</para>
    /// <para> * @next Cancel</para>
    /// <para></para>
    /// </summary>
    public partial class PinMatrixRequest
    {
        public global::KeepKeySharp.Contracts.PinMatrixRequestType? Type { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Computer responds with encoded PIN</para>
    /// <para> * @prev PinMatrixRequest</para>
    /// <para></para>
    /// </summary>
    public partial class PinMatrixAck
    {
        public string Pin { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Abort last operation that required user interaction</para>
    /// <para> * @prev ButtonRequest</para>
    /// <para> * @prev PinMatrixRequest</para>
    /// <para> * @prev PassphraseRequest</para>
    /// <para></para>
    /// </summary>
    public partial class Cancel
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device awaits encryption passphrase</para>
    /// <para> * @next PassphraseAck</para>
    /// <para> * @next Cancel</para>
    /// <para></para>
    /// </summary>
    public partial class PassphraseRequest
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Send passphrase back</para>
    /// <para> * @prev PassphraseRequest</para>
    /// <para></para>
    /// </summary>
    public partial class PassphraseAck
    {
        public string Passphrase { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Request a sample of random data generated by hardware RNG. May be used for testing.</para>
    /// <para> * @next ButtonRequest</para>
    /// <para> * @next Entropy</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class GetEntropy
    {
        public uint Size { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Reply with random data generated by internal RNG</para>
    /// <para> * @prev GetEntropy</para>
    /// <para></para>
    /// </summary>
    public partial class Entropy
    {
        public byte[] EntropyField { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device for public key corresponding to address_n path</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next PublicKey</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class GetPublicKey
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public string EcdsaCurveName { get; set; }

        /// <summary> ECDSA curve name to use</summary>
        public bool? ShowDisplay { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Contains public key derived from device private seed</para>
    /// <para> * @prev GetPublicKey</para>
    /// <para></para>
    /// </summary>
    public partial class PublicKey
    {
        public global::KeepKeySharp.Contracts.HDNodeType Node { get; set; }

        /// <summary> BIP32 public node</summary>
        public string Xpub { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device for address corresponding to address_n path</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next Address</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class GetAddress
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public string CoinName { get; set; }

        public bool? ShowDisplay { get; set; }

        /// <summary> optionally show on display before sending the result</summary>
        public global::KeepKeySharp.Contracts.MultisigRedeemScriptType Multisig { get; set; }

        /// <summary> Filled if we are showing a multisig address</summary>
        public global::KeepKeySharp.Contracts.InputScriptType? ScriptType { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device for Ethereum address corresponding to address_n path</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next EthereumAddress</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class EthereumGetAddress
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public bool? ShowDisplay { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Contains address derived from device private seed</para>
    /// <para> * @prev GetAddress</para>
    /// <para></para>
    /// </summary>
    public partial class Address
    {
        public string AddressField { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Contains an Ethereum address derived from device private seed</para>
    /// <para> * @prev EthereumGetAddress</para>
    /// <para></para>
    /// </summary>
    public partial class EthereumAddress
    {
        public byte[] Address { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Request device to wipe all sensitive data and settings</para>
    /// <para> * @next ButtonRequest</para>
    /// <para></para>
    /// </summary>
    public partial class WipeDevice
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Load seed and related internal settings from the computer</para>
    /// <para> * @next ButtonRequest</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class LoadDevice
    {
        public string Mnemonic { get; set; }

        /// <summary> seed encoded as BIP-39 mnemonic (12, 18 or 24 words)</summary>
        public global::KeepKeySharp.Contracts.HDNodeType Node { get; set; }

        /// <summary> BIP-32 node</summary>
        public string Pin { get; set; }

        /// <summary> set PIN protection</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> enable master node encryption using passphrase</summary>
        public string Language { get; set; }

        /// <summary> device language</summary>
        public string Label { get; set; }

        /// <summary> device label</summary>
        public bool? SkipChecksum { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to do initialization involving user interaction</para>
    /// <para> * @next EntropyRequest</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class ResetDevice
    {
        public bool? DisplayRandom { get; set; }

        /// <summary> display entropy generated by the device before asking for additional entropy</summary>
        public uint? Strength { get; set; }

        /// <summary> strength of seed in bits</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> enable master node encryption using passphrase</summary>
        public bool? PinProtection { get; set; }

        /// <summary> enable PIN protection</summary>
        public string Language { get; set; }

        /// <summary> device language</summary>
        public string Label { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Ask for additional entropy from host computer</para>
    /// <para> * @prev ResetDevice</para>
    /// <para> * @next EntropyAck</para>
    /// <para></para>
    /// </summary>
    public partial class EntropyRequest
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Provide additional entropy for seed generation function</para>
    /// <para> * @prev EntropyRequest</para>
    /// <para> * @next ButtonRequest</para>
    /// <para></para>
    /// </summary>
    public partial class EntropyAck
    {
        public byte[] Entropy { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Start recovery workflow asking user for specific words of mnemonic</para>
    /// <para> * Used to recovery device safely even on untrusted computer.</para>
    /// <para> * @next WordRequest</para>
    /// <para></para>
    /// </summary>
    public partial class RecoveryDevice
    {
        public uint? WordCount { get; set; }

        /// <summary> number of words in BIP-39 mnemonic</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> enable master node encryption using passphrase</summary>
        public bool? PinProtection { get; set; }

        /// <summary> enable PIN protection</summary>
        public string Language { get; set; }

        /// <summary> device language</summary>
        public string Label { get; set; }

        /// <summary> device label</summary>
        public bool? EnforceWordlist { get; set; }

        /// <summary> enforce BIP-39 wordlist during the process</summary>
        public bool? UseCharacterCipher { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device is waiting for user to enter word of the mnemonic</para>
    /// <para> * Its position is shown only on device's internal display.</para>
    /// <para> * @prev RecoveryDevice</para>
    /// <para> * @prev WordAck</para>
    /// <para></para>
    /// </summary>
    public partial class WordRequest
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Computer replies with word from the mnemonic</para>
    /// <para> * @prev WordRequest</para>
    /// <para> * @next WordRequest</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class WordAck
    {
        public string Word { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device is waiting for user to enter character of the mnemonic using cipher.</para>
    /// <para> * The cipher is shown on device's internal display.</para>
    /// <para> * @prev RecoveryDevice</para>
    /// <para> * @prev CharacterAck</para>
    /// <para></para>
    /// </summary>
    public partial class CharacterRequest
    {
        public uint WordPos { get; set; }

        /// <summary> word position in BIP-39 mnemonic</summary>
        public uint CharacterPos { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Computer replies with character from the mnemonic using cipher</para>
    /// <para> * @prev CharacterRequest</para>
    /// <para> * @next CharacterRequest</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class CharacterAck
    {
        public string Character { get; set; }

        /// <summary> one character of mnemonic using cipher</summary>
        public bool? Delete { get; set; }

        /// <summary> request to delete previous character from ciphered mnemonic</summary>
        public bool? Done { get; set; }

    }

    /// <summary>
    /// <para> Message signing messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Ask device to sign message</para>
    /// <para> * @next MessageSignature</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class SignMessage
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public byte[] Message { get; set; }

        /// <summary> message to be signed</summary>
        public string CoinName { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to verify message</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class VerifyMessage
    {
        public string Address { get; set; }

        /// <summary> address to verify</summary>
        public byte[] Signature { get; set; }

        /// <summary> signature to verify</summary>
        public byte[] Message { get; set; }

        /// <summary> message to verify</summary>
        public string CoinName { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Signed message</para>
    /// <para> * @prev SignMessage</para>
    /// <para></para>
    /// </summary>
    public partial class MessageSignature
    {
        public string Address { get; set; }

        /// <summary> address used to sign the message</summary>
        public byte[] Signature { get; set; }

    }

    /// <summary>
    /// <para> Encryption/decryption //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Ask device to encrypt message</para>
    /// <para> * @next EncryptedMessage</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class EncryptMessage
    {
        public byte[] Pubkey { get; set; }

        /// <summary> public key</summary>
        public byte[] Message { get; set; }

        /// <summary> message to encrypt</summary>
        public bool? DisplayOnly { get; set; }

        /// <summary> show just on display? (don't send back via wire)</summary>
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the signing key from master node</summary>
        public string CoinName { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Encrypted message</para>
    /// <para> * @prev EncryptMessage</para>
    /// <para></para>
    /// </summary>
    public partial class EncryptedMessage
    {
        public byte[] Nonce { get; set; }

        /// <summary> nonce used during encryption</summary>
        public byte[] Message { get; set; }

        /// <summary> encrypted message</summary>
        public byte[] Hmac { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to decrypt message</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class DecryptMessage
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the decryption key from master node</summary>
        public byte[] Nonce { get; set; }

        /// <summary> nonce used during encryption</summary>
        public byte[] Message { get; set; }

        /// <summary> message to decrypt</summary>
        public byte[] Hmac { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Decrypted message</para>
    /// <para> * @prev DecryptedMessage</para>
    /// <para></para>
    /// </summary>
    public partial class DecryptedMessage
    {
        public byte[] Message { get; set; }

        /// <summary> decrypted message</summary>
        public string Address { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to encrypt or decrypt value of given key</para>
    /// <para> * @next CipheredKeyValue</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class CipherKeyValue
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public string Key { get; set; }

        /// <summary> key component of key:value</summary>
        public byte[] Value { get; set; }

        /// <summary> value component of key:value</summary>
        public bool? Encrypt { get; set; }

        /// <summary> are we encrypting (True) or decrypting (False)?</summary>
        public bool? AskOnEncrypt { get; set; }

        /// <summary> should we ask on encrypt operation?</summary>
        public bool? AskOnDecrypt { get; set; }

        /// <summary> should we ask on decrypt operation?</summary>
        public byte[] Iv { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Return ciphered/deciphered value</para>
    /// <para> * @prev CipherKeyValue</para>
    /// <para></para>
    /// </summary>
    public partial class CipheredKeyValue
    {
        public byte[] Value { get; set; }

    }

    /// <summary>
    /// <para> Transaction signing messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request:  Estimated size of the transaction</para>
    /// <para> * This behaves exactly like SignTx, which means that it can ask using TxRequest</para>
    /// <para> * This call is non-blocking (except possible PassphraseRequest to unlock the seed)</para>
    /// <para> * @next TxSize</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class EstimateTxSize
    {
        public uint OutputsCount { get; set; }

        /// <summary> number of transaction outputs</summary>
        public uint InputsCount { get; set; }

        /// <summary> number of transaction inputs</summary>
        public string CoinName { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Estimated size of the transaction</para>
    /// <para> * @prev EstimateTxSize</para>
    /// <para></para>
    /// </summary>
    public partial class TxSize
    {
        public uint? TxSizeField { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to sign transaction</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para> * @next TxRequest</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class SignTx
    {
        public uint OutputsCount { get; set; }

        /// <summary> number of transaction outputs</summary>
        public uint InputsCount { get; set; }

        /// <summary> number of transaction inputs</summary>
        public string CoinName { get; set; }

        /// <summary> coin to use</summary>
        public uint? Version { get; set; }

        /// <summary> transaction version</summary>
        public uint? LockTime { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Simplified transaction signing</para>
    /// <para> * This method doesn't support streaming, so there are hardware limits in number of inputs and outputs.</para>
    /// <para> * In case of success, the result is returned using TxRequest message.</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para> * @next TxRequest</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class SimpleSignTx
    {
        public List<global::KeepKeySharp.Contracts.TxInputType> Inputs { get; set; }

        /// <summary> transaction inputs</summary>
        public List<global::KeepKeySharp.Contracts.TxOutputType> Outputs { get; set; }

        /// <summary> transaction outputs</summary>
        public List<global::KeepKeySharp.Contracts.TransactionType> Transactions { get; set; }

        /// <summary> transactions whose outputs are used to build current inputs</summary>
        public string CoinName { get; set; }

        /// <summary> coin to use</summary>
        public uint? Version { get; set; }

        /// <summary> transaction version</summary>
        public uint? LockTime { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device asks for information for signing transaction or returns the last result</para>
    /// <para> * If request_index is set, device awaits TxAck message (with fields filled in according to request_type)</para>
    /// <para> * If signature_index is set, 'signature' contains signed input of signature_index's input</para>
    /// <para> * @prev SignTx</para>
    /// <para> * @prev SimpleSignTx</para>
    /// <para> * @prev TxAck</para>
    /// <para></para>
    /// </summary>
    public partial class TxRequest
    {
        public global::KeepKeySharp.Contracts.RequestType? RequestType { get; set; }

        /// <summary> what should be filled in TxAck message?</summary>
        public global::KeepKeySharp.Contracts.TxRequestDetailsType Details { get; set; }

        /// <summary> request for tx details</summary>
        public global::KeepKeySharp.Contracts.TxRequestSerializedType Serialized { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Reported transaction data</para>
    /// <para> * @prev TxRequest</para>
    /// <para> * @next TxRequest</para>
    /// <para></para>
    /// </summary>
    public partial class TxAck
    {
        public global::KeepKeySharp.Contracts.TransactionType Tx { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Reported raw transaction data</para>
    /// <para> * @prev TxRequest</para>
    /// <para> * @next TxRequest</para>
    /// <para></para>
    /// </summary>
    public partial class RawTxAck
    {
        public global::KeepKeySharp.Contracts.RawTransactionType Tx { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to sign transaction</para>
    /// <para> * All fields are optional from the protocol's point of view. Each field defaults to value `0` if missing.</para>
    /// <para> * Note: the first at most 1024 bytes of data MUST be transmitted as part of this message.</para>
    /// <para> * @next PassphraseRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para> * @next EthereumTxRequest</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class EthereumSignTx
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public byte[] Nonce { get; set; }

        /// <summary> <=256 bit unsigned big endian</summary>
        public byte[] GasPrice { get; set; }

        /// <summary> <=256 bit unsigned big endian (in wei)</summary>
        public byte[] GasLimit { get; set; }

        /// <summary> <=256 bit unsigned big endian</summary>
        public byte[] To { get; set; }

        /// <summary> 160 bit address hash</summary>
        public byte[] Value { get; set; }

        /// <summary> <=256 bit unsigned big endian (in wei)</summary>
        public byte[] DataInitialChunk { get; set; }

        /// <summary> The initial data chunk (<= 1024 bytes)</summary>
        public uint? DataLength { get; set; }

        /// <summary> Length of transaction payload</summary>
        public List<uint> ToAddressN { get; set; }

        /// <summary> BIP-32 path to derive key for fund transfer</summary>
        public global::KeepKeySharp.Contracts.OutputAddressType? AddressType { get; set; }

        /// <summary> output address type</summary>
        public global::KeepKeySharp.Contracts.ExchangeType ExchangeType { get; set; }

        /// <summary> exchange type data</summary>
        public uint? ChainId { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device asks for more data from transaction payload, or returns the signature.</para>
    /// <para> * If data_length is set, device awaits that many more bytes of payload.</para>
    /// <para> * Otherwise, the signature_* fields contain the computed transaction signature. All three fields will be present.</para>
    /// <para> * @prev EthereumSignTx</para>
    /// <para> * @next EthereumTxAck</para>
    /// <para></para>
    /// </summary>
    public partial class EthereumTxRequest
    {
        public uint? DataLength { get; set; }

        /// <summary> Number of bytes being requested (<= 1024)</summary>
        public uint? SignatureV { get; set; }

        /// <summary> Computed signature (recovery parameter, limited to 27 or 28)</summary>
        public byte[] SignatureR { get; set; }

        /// <summary> Computed signature R component (256 bit)</summary>
        public byte[] SignatureS { get; set; }

        /// <summary> Computed signature S component (256 bit)</summary>
        public byte[] Hash { get; set; }

        /// <summary> Computed hash using SHA3 (keccak_ctx)</summary>
        public byte[] SignatureDer { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Transaction payload data.</para>
    /// <para> * @prev EthereumTxRequest</para>
    /// <para> * @next EthereumTxRequest</para>
    /// <para></para>
    /// </summary>
    public partial class EthereumTxAck
    {
        public byte[] DataChunk { get; set; }

    }

    /// <summary>
    /// <para> Identity messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Ask device to sign identity</para>
    /// <para> * @next SignedIdentity</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class SignIdentity
    {
        public global::KeepKeySharp.Contracts.IdentityType Identity { get; set; }

        /// <summary> identity</summary>
        public byte[] ChallengeHidden { get; set; }

        /// <summary> non-visible challenge</summary>
        public string ChallengeVisual { get; set; }

        /// <summary> challenge shown on display (e.g. date+time)</summary>
        public string EcdsaCurveName { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device provides signed identity</para>
    /// <para> * @prev SignIdentity</para>
    /// <para></para>
    /// </summary>
    public partial class SignedIdentity
    {
        public string Address { get; set; }

        /// <summary> identity address</summary>
        public byte[] PublicKey { get; set; }

        /// <summary> identity public key</summary>
        public byte[] Signature { get; set; }

    }

    /// <summary>
    /// <para> Policy messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Ask device to apply policy</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para> * @next ButtonRequest</para>
    /// <para> * @next PinMatrixRequest</para>
    /// <para></para>
    /// </summary>
    public partial class ApplyPolicies
    {
        public List<global::KeepKeySharp.Contracts.PolicyType> Policy { get; set; }

    }

    /// <summary>
    /// <para> Bootloader messages //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: Ask device to erase its firmware</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class FirmwareErase
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Send firmware in binary form to the device</para>
    /// <para> * @next Success</para>
    /// <para> * @next Failure</para>
    /// <para></para>
    /// </summary>
    public partial class FirmwareUpload
    {
        public byte[] PayloadHash { get; set; }

        /// <summary> sha256 hash of payload (meta + firmware)</summary>
        public byte[] Payload { get; set; }

    }

    /// <summary>
    /// <para> Debug messages (only available if DebugLink is enabled) //</para>
    /// <para></para>
    /// <para>*</para>
    /// <para> * Request: "Press" the button on the device</para>
    /// <para> * @next Success</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkDecision
    {
        public bool YesNo { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Computer asks for device state</para>
    /// <para> * @next DebugLinkState</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkGetState
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device current state</para>
    /// <para> * @prev DebugLinkGetState</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkState
    {
        public byte[] Layout { get; set; }

        /// <summary> raw buffer of display</summary>
        public string Pin { get; set; }

        /// <summary> current PIN, blank if PIN is not set/enabled</summary>
        public string Matrix { get; set; }

        /// <summary> current PIN matrix</summary>
        public string Mnemonic { get; set; }

        /// <summary> current BIP-39 mnemonic</summary>
        public global::KeepKeySharp.Contracts.HDNodeType Node { get; set; }

        /// <summary> current BIP-32 node</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> is node/mnemonic encrypted using passphrase?</summary>
        public string ResetWord { get; set; }

        /// <summary> word on device display during ResetDevice workflow</summary>
        public byte[] ResetEntropy { get; set; }

        /// <summary> current entropy during ResetDevice workflow</summary>
        public string RecoveryFakeWord { get; set; }

        /// <summary> (fake) word on display during RecoveryDevice workflow</summary>
        public uint? RecoveryWordPos { get; set; }

        /// <summary> index of mnemonic word the device is expecting during RecoveryDevice workflow</summary>
        public string RecoveryCipher { get; set; }

        /// <summary> current recovery cipher</summary>
        public string RecoveryAutoCompletedWord { get; set; }

        /// <summary> last auto completed recovery word</summary>
        public byte[] FirmwareHash { get; set; }

        /// <summary> hash of the application and meta header</summary>
        public byte[] StorageHash { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to restart</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkStop
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Response: Device wants host to log event</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkLog
    {
        public uint? Level { get; set; }

        public string Bucket { get; set; }

        public string Text { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Request: Ask device to fill config area with sample data (used for testing firmware upload)</para>
    /// <para></para>
    /// </summary>
    public partial class DebugLinkFillConfig
    {
    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Internal persistent storage of device</para>
    /// <para></para>
    /// </summary>
    public partial class Storage
    {
        public uint Version { get; set; }

        /// <summary> version of storage</summary>
        public global::KeepKeySharp.Contracts.HDNodeType Node { get; set; }

        /// <summary> BIP-32 node (mnemonic cannot be used if this is present)</summary>
        public string Mnemonic { get; set; }

        /// <summary> BIP-39 mnemonic (node cannot be used if this is present)</summary>
        public bool? PassphraseProtection { get; set; }

        /// <summary> whether to require passphrase to decrypt node or stretch mnemonic</summary>
        public uint? PinFailedAttempts { get; set; }

        /// <summary> number of failed PIN attempts</summary>
        public string Pin { get; set; }

        /// <summary> current PIN</summary>
        public string Language { get; set; }

        /// <summary> current language</summary>
        public string Label { get; set; }

        /// <summary> device label</summary>
        public bool? Imported { get; set; }

        /// <summary> was storage imported from an external source?</summary>
        public List<global::KeepKeySharp.Contracts.PolicyType> Policies { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing BIP32 (hierarchical deterministic) node</para>
    /// <para> * Used for imports of private key into the device and exporting public key out of device</para>
    /// <para> * @used_in PublicKey</para>
    /// <para> * @used_in LoadDevice</para>
    /// <para> * @used_in DebugLinkState</para>
    /// <para> * @used_in Storage</para>
    /// <para></para>
    /// </summary>
    public partial class HDNodeType
    {
        public uint Depth { get; set; }

        public uint Fingerprint { get; set; }

        public uint ChildNum { get; set; }

        public byte[] ChainCode { get; set; }

        public byte[] PrivateKey { get; set; }

        public byte[] PublicKey { get; set; }

    }

    public partial class HDNodePathType
    {
        public global::KeepKeySharp.Contracts.HDNodeType Node { get; set; }

        /// <summary> BIP-32 node in deserialized form</summary>
        public List<uint> AddressN { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing Coin</para>
    /// <para> * @used_in Features</para>
    /// <para></para>
    /// </summary>
    public partial class CoinType
    {
        public string CoinName { get; set; }

        public string CoinShortcut { get; set; }

        public uint? AddressType { get; set; }

        public ulong? MaxfeeKb { get; set; }

        public uint? AddressTypeP2sh { get; set; }

        public uint? AddressTypeP2wpkh { get; set; }

        public uint? AddressTypeP2wsh { get; set; }

        public string SignedMessageHeader { get; set; }

        public uint? Bip44AccountPath { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Type of redeem script used in input</para>
    /// <para> * @used_in TxInputType</para>
    /// <para></para>
    /// </summary>
    public partial class MultisigRedeemScriptType
    {
        public List<global::KeepKeySharp.Contracts.HDNodePathType> Pubkeys { get; set; }

        /// <summary> pubkeys from multisig address (sorted lexicographically)</summary>
        public List<byte[]> Signatures { get; set; }

        /// <summary> existing signatures for partially signed input</summary>
        public uint? M { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing transaction input</para>
    /// <para> * @used_in SimpleSignTx</para>
    /// <para> * @used_in TransactionType</para>
    /// <para></para>
    /// </summary>
    public partial class TxInputType
    {
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node</summary>
        public byte[] PrevHash { get; set; }

        /// <summary> hash of previous transaction output to spend by this input</summary>
        public uint PrevIndex { get; set; }

        /// <summary> index of previous output to spend</summary>
        public byte[] ScriptSig { get; set; }

        /// <summary> script signature, unset for tx to sign</summary>
        public uint? Sequence { get; set; }

        /// <summary> sequence</summary>
        public global::KeepKeySharp.Contracts.InputScriptType? ScriptType { get; set; }

        /// <summary> defines template of input script</summary>
        public global::KeepKeySharp.Contracts.MultisigRedeemScriptType Multisig { get; set; }

        /// <summary> Filled if input is going to spend multisig tx</summary>
        public ulong? Amount { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing transaction output</para>
    /// <para> * @used_in SimpleSignTx</para>
    /// <para> * @used_in TransactionType</para>
    /// <para></para>
    /// </summary>
    public partial class TxOutputType
    {
        public string Address { get; set; }

        /// <summary> target coin address in Base58 encoding</summary>
        public List<uint> AddressN { get; set; }

        /// <summary> BIP-32 path to derive the key from master node; has higher priority than "address"</summary>
        public ulong Amount { get; set; }

        /// <summary> amount to spend in satoshis</summary>
        public global::KeepKeySharp.Contracts.OutputScriptType ScriptType { get; set; }

        /// <summary> output script type</summary>
        public global::KeepKeySharp.Contracts.MultisigRedeemScriptType Multisig { get; set; }

        /// <summary> defines multisig address; script_type must be PAYTOMULTISIG</summary>
        public byte[] OpReturnData { get; set; }

        /// <summary> defines op_return data; script_type must be PAYTOOPRETURN, amount must be 0</summary>
        public global::KeepKeySharp.Contracts.OutputAddressType? AddressType { get; set; }

        /// <summary> output address type</summary>
        public global::KeepKeySharp.Contracts.ExchangeType ExchangeType { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing compiled transaction output</para>
    /// <para> * @used_in TransactionType</para>
    /// <para></para>
    /// </summary>
    public partial class TxOutputBinType
    {
        public ulong Amount { get; set; }

        public byte[] ScriptPubkey { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing transaction</para>
    /// <para> * @used_in SimpleSignTx,</para>
    /// <para></para>
    /// </summary>
    public partial class TransactionType
    {
        public uint? Version { get; set; }

        public List<global::KeepKeySharp.Contracts.TxInputType> Inputs { get; set; }

        public List<global::KeepKeySharp.Contracts.TxOutputBinType> BinOutputs { get; set; }

        public List<global::KeepKeySharp.Contracts.TxOutputType> Outputs { get; set; }

        public uint? LockTime { get; set; }

        public uint? InputsCnt { get; set; }

        public uint? OutputsCnt { get; set; }

        public byte[] ExtraData { get; set; }

        public uint? ExtraDataLen { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing raw transaction</para>
    /// <para> * @used_in RawTxAck</para>
    /// <para></para>
    /// </summary>
    public partial class RawTransactionType
    {
        public byte[] Payload { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing request details</para>
    /// <para> * @used_in TxRequest</para>
    /// <para></para>
    /// </summary>
    public partial class TxRequestDetailsType
    {
        public uint? RequestIndex { get; set; }

        /// <summary> device expects TxAck message from the computer</summary>
        public byte[] TxHash { get; set; }

        /// <summary> tx_hash of requested transaction</summary>
        public uint? ExtraDataLen { get; set; }

        /// <summary> length of requested extra data</summary>
        public uint? ExtraDataOffset { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing serialized data</para>
    /// <para> * @used_in TxRequest</para>
    /// <para></para>
    /// </summary>
    public partial class TxRequestSerializedType
    {
        public uint? SignatureIndex { get; set; }

        /// <summary> 'signature' field contains signed input of this index</summary>
        public byte[] Signature { get; set; }

        /// <summary> signature of the signature_index input</summary>
        public byte[] SerializedTx { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing identity data</para>
    /// <para> * @used_in IdentityType</para>
    /// <para></para>
    /// </summary>
    public partial class IdentityType
    {
        public string Proto { get; set; }

        /// <summary> proto part of URI</summary>
        public string User { get; set; }

        /// <summary> user part of URI</summary>
        public string Host { get; set; }

        /// <summary> host part of URI</summary>
        public string Port { get; set; }

        /// <summary> port part of URI</summary>
        public string Path { get; set; }

        /// <summary> path part of URI</summary>
        public uint? Index { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing policy data</para>
    /// <para> * @used_in ApplyPolicy</para>
    /// <para></para>
    /// </summary>
    public partial class PolicyType
    {
        public string PolicyName { get; set; }

        /// <summary> name of policy</summary>
        public bool? Enabled { get; set; }

    }

    /// <summary>
    /// <para>*</para>
    /// <para> * Structure representing exchange data</para>
    /// <para> * @used_in TxOutputType</para>
    /// <para></para>
    /// </summary>
    public partial class ExchangeType
    {
        public global::KeepKeySharp.Contracts.SignedExchangeResponse SignedExchangeResponse { get; set; }

        /// <summary> exchange response</summary>
        public string WithdrawalCoinName { get; set; }

        /// <summary> coin type of the received funds</summary>
        public List<uint> WithdrawalAddressN { get; set; }

        /// <summary> BIP-32 path for received funds</summary>
        public List<uint> ReturnAddressN { get; set; }

    }

}
namespace Google.Protobuf
{
    /// <summary>
    /// <para> The protocol compiler can output a FileDescriptorSet containing the .proto</para>
    /// <para> files it parses.</para>
    /// </summary>
    public partial class FileDescriptorSet
    {
        public List<global::Google.Protobuf.FileDescriptorProto> File { get; set; }

    }

    /// <summary> Describes a complete .proto file.</summary>
    public partial class FileDescriptorProto
    {
        public string Name { get; set; }

        /// <summary> file name, relative to root of source tree</summary>
        public string Package { get; set; }

        /// <summary>
        /// <para> e.g. "foo", "foo.bar", etc.</para>
        /// <para> Names of files imported by this file.</para>
        /// </summary>
        public List<string> Dependency { get; set; }

        /// <summary> Indexes of the public imported files in the dependency list above.</summary>
        public List<int> PublicDependency { get; set; }

        /// <summary>
        /// <para> Indexes of the weak imported files in the dependency list.</para>
        /// <para> For Google-internal migration only. Do not use.</para>
        /// </summary>
        public List<int> WeakDependency { get; set; }

        /// <summary> All top-level definitions in this file.</summary>
        public List<global::Google.Protobuf.DescriptorProto> MessageType { get; set; }

        public List<global::Google.Protobuf.EnumDescriptorProto> EnumType { get; set; }

        public List<global::Google.Protobuf.ServiceDescriptorProto> Service { get; set; }

        public List<global::Google.Protobuf.FieldDescriptorProto> Extension { get; set; }

        public global::Google.Protobuf.FileOptions Options { get; set; }

        /// <summary>
        /// <para> This field contains optional information about the original source code.</para>
        /// <para> You may safely remove this entire field whithout harming runtime</para>
        /// <para> functionality of the descriptors -- the information is needed only by</para>
        /// <para> development tools.</para>
        /// </summary>
        public global::Google.Protobuf.SourceCodeInfo SourceCodeInfo { get; set; }

    }

    /// <summary> Describes a message type.</summary>
    public partial class DescriptorProto
    {
        public string Name { get; set; }

        public List<global::Google.Protobuf.FieldDescriptorProto> Field { get; set; }

        public List<global::Google.Protobuf.FieldDescriptorProto> Extension { get; set; }

        public List<global::Google.Protobuf.DescriptorProto> NestedType { get; set; }

        public List<global::Google.Protobuf.EnumDescriptorProto> EnumType { get; set; }

        public List<global::Google.Protobuf.DescriptorProto.ExtensionRange> ExtensionRangeField { get; set; }

        public global::Google.Protobuf.MessageOptions Options { get; set; }

        public partial class ExtensionRange
        {
            public int? Start { get; set; }

            public int? End { get; set; }

        }

    }

    /// <summary> Describes a field within a message.</summary>
    public partial class FieldDescriptorProto
    {
        public enum Type
        {
            /// <summary>
            /// <para> 0 is reserved for errors.</para>
            /// <para> Order is weird for historical reasons.</para>
            /// </summary>
            TYPE_DOUBLE = 1,
            TYPE_FLOAT = 2,
            /// <summary>
            /// <para> Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT64 if</para>
            /// <para> negative values are likely.</para>
            /// </summary>
            TYPE_INT64 = 3,
            TYPE_UINT64 = 4,
            /// <summary>
            /// <para> Not ZigZag encoded.  Negative numbers take 10 bytes.  Use TYPE_SINT32 if</para>
            /// <para> negative values are likely.</para>
            /// </summary>
            TYPE_INT32 = 5,
            TYPE_FIXED64 = 6,
            TYPE_FIXED32 = 7,
            TYPE_BOOL = 8,
            TYPE_STRING = 9,
            TYPE_GROUP = 10,
            /// <summary> Tag-delimited aggregate.</summary>
            TYPE_MESSAGE = 11,
            /// <summary>
            /// <para> Length-delimited aggregate.</para>
            /// <para> New in version 2.</para>
            /// </summary>
            TYPE_BYTES = 12,
            TYPE_UINT32 = 13,
            TYPE_ENUM = 14,
            TYPE_SFIXED32 = 15,
            TYPE_SFIXED64 = 16,
            TYPE_SINT32 = 17,
            /// <summary> Uses ZigZag encoding.</summary>
            TYPE_SINT64 = 18,
        }

        public enum Label
        {
            /// <summary> 0 is reserved for errors</summary>
            LABEL_OPTIONAL = 1,
            LABEL_REQUIRED = 2,
            LABEL_REPEATED = 3,
        }

        public string Name { get; set; }

        public int? Number { get; set; }

        public global::Google.Protobuf.FieldDescriptorProto.Label? label { get; set; }

        /// <summary>
        /// <para> If type_name is set, this need not be set.  If both this and type_name</para>
        /// <para> are set, this must be either TYPE_ENUM or TYPE_MESSAGE.</para>
        /// </summary>
        public global::Google.Protobuf.FieldDescriptorProto.Type? type { get; set; }

        /// <summary>
        /// <para> For message and enum types, this is the name of the type.  If the name</para>
        /// <para> starts with a '.', it is fully-qualified.  Otherwise, C++-like scoping</para>
        /// <para> rules are used to find the type (i.e. first the nested types within this</para>
        /// <para> message are searched, then within the parent, on up to the root</para>
        /// <para> namespace).</para>
        /// </summary>
        public string TypeName { get; set; }

        /// <summary>
        /// <para> For extensions, this is the name of the type being extended.  It is</para>
        /// <para> resolved in the same manner as type_name.</para>
        /// </summary>
        public string Extendee { get; set; }

        /// <summary>
        /// <para> For numeric types, contains the original text representation of the value.</para>
        /// <para> For booleans, "true" or "false".</para>
        /// <para> For strings, contains the default text contents (not escaped in any way).</para>
        /// <para> For bytes, contains the C escaped value.  All bytes >= 128 are escaped.</para>
        /// <para> TODO(kenton):  Base-64 encode?</para>
        /// </summary>
        public string DefaultValue { get; set; }

        public global::Google.Protobuf.FieldOptions Options { get; set; }

    }

    /// <summary> Describes an enum type.</summary>
    public partial class EnumDescriptorProto
    {
        public string Name { get; set; }

        public List<global::Google.Protobuf.EnumValueDescriptorProto> Value { get; set; }

        public global::Google.Protobuf.EnumOptions Options { get; set; }

    }

    /// <summary> Describes a value within an enum.</summary>
    public partial class EnumValueDescriptorProto
    {
        public string Name { get; set; }

        public int? Number { get; set; }

        public global::Google.Protobuf.EnumValueOptions Options { get; set; }

    }

    /// <summary> Describes a service.</summary>
    public partial class ServiceDescriptorProto
    {
        public string Name { get; set; }

        public List<global::Google.Protobuf.MethodDescriptorProto> Method { get; set; }

        public global::Google.Protobuf.ServiceOptions Options { get; set; }

    }

    /// <summary> Describes a method of a service.</summary>
    public partial class MethodDescriptorProto
    {
        public string Name { get; set; }

        /// <summary>
        /// <para> Input and output type names.  These are resolved in the same way as</para>
        /// <para> FieldDescriptorProto.type_name, but must refer to a message type.</para>
        /// </summary>
        public string InputType { get; set; }

        public string OutputType { get; set; }

        public global::Google.Protobuf.MethodOptions Options { get; set; }

    }

    /// <summary>
    /// <para> ===================================================================</para>
    /// <para> Options</para>
    /// <para> Each of the definitions above may have "options" attached.  These are</para>
    /// <para> just annotations which may cause code to be generated slightly differently</para>
    /// <para> or may contain hints for code that manipulates protocol messages.</para>
    /// <para></para>
    /// <para> Clients may define custom options as extensions of the *Options messages.</para>
    /// <para> These extensions may not yet be known at parsing time, so the parser cannot</para>
    /// <para> store the values in them.  Instead it stores them in a field in the *Options</para>
    /// <para> message called uninterpreted_option. This field must have the same name</para>
    /// <para> across all *Options messages. We then use this field to populate the</para>
    /// <para> extensions when we build a descriptor, at which point all protos have been</para>
    /// <para> parsed and so all extensions are known.</para>
    /// <para></para>
    /// <para> Extension numbers for custom options may be chosen as follows:</para>
    /// <para> * For options which will only be used within a single application or</para>
    /// <para>   organization, or for experimental options, use field numbers 50000</para>
    /// <para>   through 99999.  It is up to you to ensure that you do not use the</para>
    /// <para>   same number for multiple options.</para>
    /// <para> * For options which will be published and used publicly by multiple</para>
    /// <para>   independent entities, e-mail protobuf-global-extension-registry@google.com</para>
    /// <para>   to reserve extension numbers. Simply provide your project name (e.g.</para>
    /// <para>   Object-C plugin) and your porject website (if available) -- there's no need</para>
    /// <para>   to explain how you intend to use them. Usually you only need one extension</para>
    /// <para>   number. You can declare multiple options with only one extension number by</para>
    /// <para>   putting them in a sub-message. See the Custom Options section of the docs</para>
    /// <para>   for examples:</para>
    /// <para>   http://code.google.com/apis/protocolbuffers/docs/proto.html#options</para>
    /// <para>   If this turns out to be popular, a web service will be set up</para>
    /// <para>   to automatically assign option numbers.</para>
    /// </summary>
    public partial class FileOptions
    {
        /// <summary> Generated classes can be optimized for speed or code size.</summary>
        public enum OptimizeMode
        {
            SPEED = 1,
            /// <summary>
            /// <para> Generate complete code for parsing, serialization,</para>
            /// <para> etc.</para>
            /// </summary>
            CODE_SIZE = 2,
            /// <summary> Use ReflectionOps to implement these methods.</summary>
            LITE_RUNTIME = 3,
        }

        /// <summary>
        /// <para> Sets the Java package where classes generated from this .proto will be</para>
        /// <para> placed.  By default, the proto package is used, but this is often</para>
        /// <para> inappropriate because proto packages do not normally start with backwards</para>
        /// <para> domain names.</para>
        /// </summary>
        public string JavaPackage { get; set; }

        /// <summary>
        /// <para> If set, all the classes from the .proto file are wrapped in a single</para>
        /// <para> outer class with the given name.  This applies to both Proto1</para>
        /// <para> (equivalent to the old "--one_java_file" option) and Proto2 (where</para>
        /// <para> a .proto always translates to a single class, but you may want to</para>
        /// <para> explicitly choose the class name).</para>
        /// </summary>
        public string JavaOuterClassname { get; set; }

        /// <summary>
        /// <para> If set true, then the Java code generator will generate a separate .java</para>
        /// <para> file for each top-level message, enum, and service defined in the .proto</para>
        /// <para> file.  Thus, these types will *not* be nested inside the outer class</para>
        /// <para> named by java_outer_classname.  However, the outer class will still be</para>
        /// <para> generated to contain the file's getDescriptor() method as well as any</para>
        /// <para> top-level extensions defined in the file.</para>
        /// </summary>
        public bool? JavaMultipleFiles { get; set; }

        /// <summary>
        /// <para> If set true, then the Java code generator will generate equals() and</para>
        /// <para> hashCode() methods for all messages defined in the .proto file. This is</para>
        /// <para> purely a speed optimization, as the AbstractMessage base class includes</para>
        /// <para> reflection-based implementations of these methods.</para>
        /// </summary>
        public bool? JavaGenerateEqualsAndHash { get; set; }

        /// <summary> Generate code using MessageLite and the lite runtime.</summary>
        public global::Google.Protobuf.FileOptions.OptimizeMode? OptimizeFor { get; set; }

        /// <summary>
        /// <para> Sets the Go package where structs generated from this .proto will be</para>
        /// <para> placed.  There is no default.</para>
        /// </summary>
        public string GoPackage { get; set; }

        /// <summary>
        /// <para> Should generic services be generated in each language?  "Generic" services</para>
        /// <para> are not specific to any particular RPC system.  They are generated by the</para>
        /// <para> main code generators in each language (without additional plugins).</para>
        /// <para> Generic services were the only kind of service generation supported by</para>
        /// <para> early versions of proto2.</para>
        /// <para></para>
        /// <para> Generic services are now considered deprecated in favor of using plugins</para>
        /// <para> that generate code specific to your particular RPC system.  Therefore,</para>
        /// <para> these default to false.  Old code which depends on generic services should</para>
        /// <para> explicitly set them to true.</para>
        /// </summary>
        public bool? CcGenericServices { get; set; }

        public bool? JavaGenericServices { get; set; }

        public bool? PyGenericServices { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class MessageOptions
    {
        /// <summary>
        /// <para> Set true to use the old proto1 MessageSet wire format for extensions.</para>
        /// <para> This is provided for backwards-compatibility with the MessageSet wire</para>
        /// <para> format.  You should not use this for any other reason:  It's less</para>
        /// <para> efficient, has fewer features, and is more complicated.</para>
        /// <para></para>
        /// <para> The message must be defined exactly as follows:</para>
        /// <para>   message Foo {</para>
        /// <para>     option message_set_wire_format = true;</para>
        /// <para>     extensions 4 to max;</para>
        /// <para>   }</para>
        /// <para> Note that the message cannot have any defined fields; MessageSets only</para>
        /// <para> have extensions.</para>
        /// <para></para>
        /// <para> All extensions of your type must be singular messages; e.g. they cannot</para>
        /// <para> be int32s, enums, or repeated messages.</para>
        /// <para></para>
        /// <para> Because this is an option, the above two restrictions are not enforced by</para>
        /// <para> the protocol compiler.</para>
        /// </summary>
        public bool? MessageSetWireFormat { get; set; }

        /// <summary>
        /// <para> Disables the generation of the standard "descriptor()" accessor, which can</para>
        /// <para> conflict with a field of the same name.  This is meant to make migration</para>
        /// <para> from proto1 easier; new code should avoid fields named "descriptor".</para>
        /// </summary>
        public bool? NoStandardDescriptorAccessor { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class FieldOptions
    {
        public enum CType
        {
            /// <summary> Default mode.</summary>
            STRING = 0,
            CORD = 1,
            STRING_PIECE = 2,
        }

        /// <summary>
        /// <para> The ctype option instructs the C++ code generator to use a different</para>
        /// <para> representation of the field than it normally would.  See the specific</para>
        /// <para> options below.  This option is not yet implemented in the open source</para>
        /// <para> release -- sorry, we'll try to include it in a future version!</para>
        /// </summary>
        public global::Google.Protobuf.FieldOptions.CType? Ctype { get; set; }

        /// <summary>
        /// <para> The packed option can be enabled for repeated primitive fields to enable</para>
        /// <para> a more efficient representation on the wire. Rather than repeatedly</para>
        /// <para> writing the tag and type for each element, the entire array is encoded as</para>
        /// <para> a single length-delimited blob.</para>
        /// </summary>
        public bool? Packed { get; set; }

        /// <summary>
        /// <para> Should this field be parsed lazily?  Lazy applies only to message-type</para>
        /// <para> fields.  It means that when the outer message is initially parsed, the</para>
        /// <para> inner message's contents will not be parsed but instead stored in encoded</para>
        /// <para> form.  The inner message will actually be parsed when it is first accessed.</para>
        /// <para></para>
        /// <para> This is only a hint.  Implementations are free to choose whether to use</para>
        /// <para> eager or lazy parsing regardless of the value of this option.  However,</para>
        /// <para> setting this option true suggests that the protocol author believes that</para>
        /// <para> using lazy parsing on this field is worth the additional bookkeeping</para>
        /// <para> overhead typically needed to implement it.</para>
        /// <para></para>
        /// <para> This option does not affect the public interface of any generated code;</para>
        /// <para> all method signatures remain the same.  Furthermore, thread-safety of the</para>
        /// <para> interface is not affected by this option; const methods remain safe to</para>
        /// <para> call from multiple threads concurrently, while non-const methods continue</para>
        /// <para> to require exclusive access.</para>
        /// <para></para>
        /// <para></para>
        /// <para> Note that implementations may choose not to check required fields within</para>
        /// <para> a lazy sub-message.  That is, calling IsInitialized() on the outher message</para>
        /// <para> may return true even if the inner message has missing required fields.</para>
        /// <para> This is necessary because otherwise the inner message would have to be</para>
        /// <para> parsed in order to perform the check, defeating the purpose of lazy</para>
        /// <para> parsing.  An implementation which chooses not to check required fields</para>
        /// <para> must be consistent about it.  That is, for any particular sub-message, the</para>
        /// <para> implementation must either *always* check its required fields, or *never*</para>
        /// <para> check its required fields, regardless of whether or not the message has</para>
        /// <para> been parsed.</para>
        /// </summary>
        public bool? Lazy { get; set; }

        /// <summary>
        /// <para> Is this field deprecated?</para>
        /// <para> Depending on the target platform, this can emit Deprecated annotations</para>
        /// <para> for accessors, or it will be completely ignored; in the very least, this</para>
        /// <para> is a formalization for deprecating fields.</para>
        /// </summary>
        public bool? Deprecated { get; set; }

        /// <summary>
        /// <para> EXPERIMENTAL.  DO NOT USE.</para>
        /// <para> For "map" fields, the name of the field in the enclosed type that</para>
        /// <para> is the key for this map.  For example, suppose we have:</para>
        /// <para>   message Item {</para>
        /// <para>     required string name = 1;</para>
        /// <para>     required string value = 2;</para>
        /// <para>   }</para>
        /// <para>   message Config {</para>
        /// <para>     repeated Item items = 1 [experimental_map_key="name"];</para>
        /// <para>   }</para>
        /// <para> In this situation, the map key for Item will be set to "name".</para>
        /// <para> TODO: Fully-implement this, then remove the "experimental_" prefix.</para>
        /// </summary>
        public string ExperimentalMapKey { get; set; }

        /// <summary> For Google-internal migration only. Do not use.</summary>
        public bool? Weak { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class EnumOptions
    {
        /// <summary>
        /// <para> Set this option to false to disallow mapping different tag names to a same</para>
        /// <para> value.</para>
        /// </summary>
        public bool? AllowAlias { get; set; }

        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class EnumValueOptions
    {
        /// <summary> The parser stores options it doesn't recognize here. See above.</summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class ServiceOptions
    {
        /// <summary>
        /// <para> Note:  Field numbers 1 through 32 are reserved for Google's internal RPC</para>
        /// <para>   framework.  We apologize for hoarding these numbers to ourselves, but</para>
        /// <para>   we were already using them long before we decided to release Protocol</para>
        /// <para>   Buffers.</para>
        /// <para> The parser stores options it doesn't recognize here. See above.</para>
        /// </summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    public partial class MethodOptions
    {
        /// <summary>
        /// <para> Note:  Field numbers 1 through 32 are reserved for Google's internal RPC</para>
        /// <para>   framework.  We apologize for hoarding these numbers to ourselves, but</para>
        /// <para>   we were already using them long before we decided to release Protocol</para>
        /// <para>   Buffers.</para>
        /// <para> The parser stores options it doesn't recognize here. See above.</para>
        /// </summary>
        public List<global::Google.Protobuf.UninterpretedOption> UninterpretedOption { get; set; }

    }

    /// <summary>
    /// <para> A message representing a option the parser does not recognize. This only</para>
    /// <para> appears in options protos created by the compiler::Parser class.</para>
    /// <para> DescriptorPool resolves these when building Descriptor objects. Therefore,</para>
    /// <para> options protos in descriptor objects (e.g. returned by Descriptor::options(),</para>
    /// <para> or produced by Descriptor::CopyTo()) will never have UninterpretedOptions</para>
    /// <para> in them.</para>
    /// </summary>
    public partial class UninterpretedOption
    {
        public List<global::Google.Protobuf.UninterpretedOption.NamePart> Name { get; set; }

        /// <summary>
        /// <para> The value of the uninterpreted option, in whatever type the tokenizer</para>
        /// <para> identified it as during parsing. Exactly one of these should be set.</para>
        /// </summary>
        public string IdentifierValue { get; set; }

        public ulong? PositiveIntValue { get; set; }

        public long? NegativeIntValue { get; set; }

        public double? DoubleValue { get; set; }

        public byte[] StringValue { get; set; }

        public string AggregateValue { get; set; }

        /// <summary>
        /// <para> The name of the uninterpreted option.  Each string represents a segment in</para>
        /// <para> a dot-separated name.  is_extension is true iff a segment represents an</para>
        /// <para> extension (denoted with parentheses in options specs in .proto files).</para>
        /// <para> E.g.,{ ["foo", false], ["bar.baz", true], ["qux", false] } represents</para>
        /// <para> "foo.(bar.baz).qux".</para>
        /// </summary>
        public partial class NamePart
        {
            public string NamePartField { get; set; }

            public bool IsExtension { get; set; }

        }

    }

    /// <summary>
    /// <para> ===================================================================</para>
    /// <para> Optional source code info</para>
    /// <para> Encapsulates information about the original source file from which a</para>
    /// <para> FileDescriptorProto was generated.</para>
    /// </summary>
    public partial class SourceCodeInfo
    {
        /// <summary>
        /// <para> A Location identifies a piece of source code in a .proto file which</para>
        /// <para> corresponds to a particular definition.  This information is intended</para>
        /// <para> to be useful to IDEs, code indexers, documentation generators, and similar</para>
        /// <para> tools.</para>
        /// <para></para>
        /// <para> For example, say we have a file like:</para>
        /// <para>   message Foo {</para>
        /// <para>     optional string foo = 1;</para>
        /// <para>   }</para>
        /// <para> Let's look at just the field definition:</para>
        /// <para>   optional string foo = 1;</para>
        /// <para>   ^       ^^     ^^  ^  ^^^</para>
        /// <para>   a       bc     de  f  ghi</para>
        /// <para> We have the following locations:</para>
        /// <para>   span   path               represents</para>
        /// <para>   [a,i)  [ 4, 0, 2, 0 ]     The whole field definition.</para>
        /// <para>   [a,b)  [ 4, 0, 2, 0, 4 ]  The label (optional).</para>
        /// <para>   [c,d)  [ 4, 0, 2, 0, 5 ]  The type (string).</para>
        /// <para>   [e,f)  [ 4, 0, 2, 0, 1 ]  The name (foo).</para>
        /// <para>   [g,h)  [ 4, 0, 2, 0, 3 ]  The number (1).</para>
        /// <para></para>
        /// <para> Notes:</para>
        /// <para> - A location may refer to a repeated field itself (i.e. not to any</para>
        /// <para>   particular index within it).  This is used whenever a set of elements are</para>
        /// <para>   logically enclosed in a single code segment.  For example, an entire</para>
        /// <para>   extend block (possibly containing multiple extension definitions) will</para>
        /// <para>   have an outer location whose path refers to the "extensions" repeated</para>
        /// <para>   field without an index.</para>
        /// <para> - Multiple locations may have the same path.  This happens when a single</para>
        /// <para>   logical declaration is spread out across multiple places.  The most</para>
        /// <para>   obvious example is the "extend" block again -- there may be multiple</para>
        /// <para>   extend blocks in the same scope, each of which will have the same path.</para>
        /// <para> - A location's span is not always a subset of its parent's span.  For</para>
        /// <para>   example, the "extendee" of an extension declaration appears at the</para>
        /// <para>   beginning of the "extend" block and is shared by all extensions within</para>
        /// <para>   the block.</para>
        /// <para> - Just because a location's span is a subset of some other location's span</para>
        /// <para>   does not mean that it is a descendent.  For example, a "group" defines</para>
        /// <para>   both a type and a field in a single declaration.  Thus, the locations</para>
        /// <para>   corresponding to the type and field and their components will overlap.</para>
        /// <para> - Code which tries to interpret locations should probably be designed to</para>
        /// <para>   ignore those that it doesn't understand, as more types of locations could</para>
        /// <para>   be recorded in the future.</para>
        /// </summary>
        public List<global::Google.Protobuf.SourceCodeInfo.Location> LocationField { get; set; }

        public partial class Location
        {
            /// <summary>
            /// <para> Identifies which part of the FileDescriptorProto was defined at this</para>
            /// <para> location.</para>
            /// <para></para>
            /// <para> Each element is a field number or an index.  They form a path from</para>
            /// <para> the root FileDescriptorProto to the place where the definition.  For</para>
            /// <para> example, this path:</para>
            /// <para>   [ 4, 3, 2, 7, 1 ]</para>
            /// <para> refers to:</para>
            /// <para>   file.message_type(3)  // 4, 3</para>
            /// <para>       .field(7)         // 2, 7</para>
            /// <para>       .name()           // 1</para>
            /// <para> This is because FileDescriptorProto.message_type has field number 4:</para>
            /// <para>   repeated DescriptorProto message_type = 4;</para>
            /// <para> and DescriptorProto.field has field number 2:</para>
            /// <para>   repeated FieldDescriptorProto field = 2;</para>
            /// <para> and FieldDescriptorProto.name has field number 1:</para>
            /// <para>   optional string name = 1;</para>
            /// <para></para>
            /// <para> Thus, the above path gives the location of a field name.  If we removed</para>
            /// <para> the last element:</para>
            /// <para>   [ 4, 3, 2, 7 ]</para>
            /// <para> this path refers to the whole field declaration (from the beginning</para>
            /// <para> of the label to the terminating semicolon).</para>
            /// </summary>
            public List<int> Path { get; set; }

            /// <summary>
            /// <para> Always has exactly three or four elements: start line, start column,</para>
            /// <para> end line (optional, otherwise assumed same as start line), end column.</para>
            /// <para> These are packed into a single field for efficiency.  Note that line</para>
            /// <para> and column numbers are zero-based -- typically you will want to add</para>
            /// <para> 1 to each before displaying to a user.</para>
            /// </summary>
            public List<int> Span { get; set; }

            /// <summary>
            /// <para> If this SourceCodeInfo represents a complete declaration, these are any</para>
            /// <para> comments appearing before and after the declaration which appear to be</para>
            /// <para> attached to the declaration.</para>
            /// <para></para>
            /// <para> A series of line comments appearing on consecutive lines, with no other</para>
            /// <para> tokens appearing on those lines, will be treated as a single comment.</para>
            /// <para></para>
            /// <para> Only the comment content is provided; comment markers (e.g. //) are</para>
            /// <para> stripped out.  For block comments, leading whitespace and an asterisk</para>
            /// <para> will be stripped from the beginning of each line other than the first.</para>
            /// <para> Newlines are included in the output.</para>
            /// <para></para>
            /// <para> Examples:</para>
            /// <para></para>
            /// <para>   optional int32 foo = 1;  // Comment attached to foo.</para>
            /// <para>   // Comment attached to bar.</para>
            /// <para>   optional int32 bar = 2;</para>
            /// <para></para>
            /// <para>   optional string baz = 3;</para>
            /// <para>   // Comment attached to baz.</para>
            /// <para>   // Another line attached to baz.</para>
            /// <para></para>
            /// <para>   // Comment attached to qux.</para>
            /// <para>   //</para>
            /// <para>   // Another line attached to qux.</para>
            /// <para>   optional double qux = 4;</para>
            /// <para></para>
            /// <para>   optional string corge = 5;</para>
            /// <para>   /* Block comment attached</para>
            /// <para>    * to corge.  Leading asterisks</para>
            /// <para>    * will be removed. */</para>
            /// <para>   /* Block comment attached to</para>
            /// <para>    * grault. */</para>
            /// <para>   optional int32 grault = 6;</para>
            /// </summary>
            public string LeadingComments { get; set; }

            public string TrailingComments { get; set; }

        }

    }

}
namespace KeepKeySharp.Contracts
{
    /// <summary>
    /// <para>*</para>
    /// <para> * Mapping between KeepKey wire identifier (uint) and a protobuf message</para>
    /// <para></para>
    /// </summary>
    public enum MessageType
    {
        MessageType_Initialize = 0,
        MessageType_Ping = 1,
        MessageType_Success = 2,
        MessageType_Failure = 3,
        MessageType_ChangePin = 4,
        MessageType_WipeDevice = 5,
        MessageType_FirmwareErase = 6,
        MessageType_FirmwareUpload = 7,
        MessageType_GetEntropy = 9,
        MessageType_Entropy = 10,
        MessageType_GetPublicKey = 11,
        MessageType_PublicKey = 12,
        MessageType_LoadDevice = 13,
        MessageType_ResetDevice = 14,
        MessageType_SignTx = 15,
        MessageType_SimpleSignTx = 16,
        MessageType_Features = 17,
        MessageType_PinMatrixRequest = 18,
        MessageType_PinMatrixAck = 19,
        MessageType_Cancel = 20,
        MessageType_TxRequest = 21,
        MessageType_TxAck = 22,
        MessageType_CipherKeyValue = 23,
        MessageType_ClearSession = 24,
        MessageType_ApplySettings = 25,
        MessageType_ButtonRequest = 26,
        MessageType_ButtonAck = 27,
        MessageType_GetAddress = 29,
        MessageType_Address = 30,
        MessageType_EntropyRequest = 35,
        MessageType_EntropyAck = 36,
        MessageType_SignMessage = 38,
        MessageType_VerifyMessage = 39,
        MessageType_MessageSignature = 40,
        MessageType_PassphraseRequest = 41,
        MessageType_PassphraseAck = 42,
        MessageType_EstimateTxSize = 43,
        MessageType_TxSize = 44,
        MessageType_RecoveryDevice = 45,
        MessageType_WordRequest = 46,
        MessageType_WordAck = 47,
        MessageType_CipheredKeyValue = 48,
        MessageType_EncryptMessage = 49,
        MessageType_EncryptedMessage = 50,
        MessageType_DecryptMessage = 51,
        MessageType_DecryptedMessage = 52,
        MessageType_SignIdentity = 53,
        MessageType_SignedIdentity = 54,
        MessageType_GetFeatures = 55,
        MessageType_EthereumGetAddress = 56,
        MessageType_EthereumAddress = 57,
        MessageType_EthereumSignTx = 58,
        MessageType_EthereumTxRequest = 59,
        MessageType_EthereumTxAck = 60,
        MessageType_CharacterRequest = 80,
        MessageType_CharacterAck = 81,
        MessageType_RawTxAck = 82,
        MessageType_ApplyPolicies = 83,
        MessageType_DebugLinkDecision = 100,
        MessageType_DebugLinkGetState = 101,
        MessageType_DebugLinkState = 102,
        MessageType_DebugLinkStop = 103,
        MessageType_DebugLinkLog = 104,
        MessageType_DebugLinkFillConfig = 105,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of failures returned by Failure message</para>
    /// <para> * @used_in Failure</para>
    /// <para></para>
    /// </summary>
    public enum FailureType
    {
        Failure_UnexpectedMessage = 1,
        Failure_ButtonExpected = 2,
        Failure_SyntaxError = 3,
        Failure_ActionCancelled = 4,
        Failure_PinExpected = 5,
        Failure_PinCancelled = 6,
        Failure_PinInvalid = 7,
        Failure_InvalidSignature = 8,
        Failure_Other = 9,
        Failure_NotEnoughFunds = 10,
        Failure_NotInitialized = 11,
        Failure_FirmwareError = 99,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of script which will be used for transaction output</para>
    /// <para> * @used_in TxOutputType</para>
    /// <para></para>
    /// </summary>
    public enum OutputScriptType
    {
        PAYTOADDRESS = 0,
        /// <summary> used for all addresses (bitcoin, p2sh, witness)</summary>
        PAYTOSCRIPTHASH = 1,
        /// <summary> p2sh address (deprecated; use PAYTOADDRESS)</summary>
        PAYTOMULTISIG = 2,
        /// <summary> only for change output</summary>
        PAYTOOPRETURN = 3,
        /// <summary> op_return</summary>
        PAYTOWITNESS = 4,
        /// <summary> only for change output</summary>
        PAYTOP2SHWITNESS = 5,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of script which will be used for transaction output</para>
    /// <para> * @used_in TxInputType</para>
    /// <para></para>
    /// </summary>
    public enum InputScriptType
    {
        SPENDADDRESS = 0,
        /// <summary> standard p2pkh address</summary>
        SPENDMULTISIG = 1,
        /// <summary> p2sh multisig address</summary>
        EXTERNAL = 2,
        /// <summary> reserved for external inputs (coinjoin)</summary>
        SPENDWITNESS = 3,
        /// <summary> native segwit</summary>
        SPENDP2SHWITNESS = 4,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of information required by transaction signing process</para>
    /// <para> * @used_in TxRequest</para>
    /// <para></para>
    /// </summary>
    public enum RequestType
    {
        TXINPUT = 0,
        TXOUTPUT = 1,
        TXMETA = 2,
        TXFINISHED = 3,
        TXEXTRADATA = 4,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of ouput address specify in transaction</para>
    /// <para> * @used_in TxOutputType</para>
    /// <para></para>
    /// </summary>
    public enum OutputAddressType
    {
        SPEND = 0,
        TRANSFER = 1,
        CHANGE = 2,
        EXCHANGE = 3,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of button request</para>
    /// <para> * @used_in ButtonRequest</para>
    /// <para></para>
    /// </summary>
    public enum ButtonRequestType
    {
        ButtonRequest_Other = 1,
        ButtonRequest_FeeOverThreshold = 2,
        ButtonRequest_ConfirmOutput = 3,
        ButtonRequest_ResetDevice = 4,
        ButtonRequest_ConfirmWord = 5,
        ButtonRequest_WipeDevice = 6,
        ButtonRequest_ProtectCall = 7,
        ButtonRequest_SignTx = 8,
        ButtonRequest_FirmwareCheck = 9,
        ButtonRequest_Address = 10,
        ButtonRequest_FirmwareErase = 11,
        ButtonRequest_ConfirmTransferToAccount = 12,
        ButtonRequest_ConfirmTransferToNodePath = 13,
        /// <summary> Deprecated!</summary>
        ButtonRequest_ChangeLabel = 14,
        ButtonRequest_ChangeLanguage = 15,
        ButtonRequest_EnablePassphrase = 16,
        ButtonRequest_DisablePassphrase = 17,
        ButtonRequest_EncryptAndSignMessage = 18,
        ButtonRequest_EncryptMessage = 19,
        ButtonRequest_ImportPrivateKey = 20,
        ButtonRequest_ImportRecoverySentence = 21,
        ButtonRequest_SignIdentity = 22,
        ButtonRequest_Ping = 23,
        ButtonRequest_RemovePin = 24,
        ButtonRequest_ChangePin = 25,
        ButtonRequest_CreatePin = 26,
        ButtonRequest_GetEntropy = 27,
        ButtonRequest_SignMessage = 28,
        ButtonRequest_ApplyPolicies = 29,
        ButtonRequest_SignExchange = 30,
    }


    /// <summary>
    /// <para>*</para>
    /// <para> * Type of PIN request</para>
    /// <para> * @used_in PinMatrixRequest</para>
    /// <para></para>
    /// </summary>
    public enum PinMatrixRequestType
    {
        PinMatrixRequestType_Current = 1,
        PinMatrixRequestType_NewFirst = 2,
        PinMatrixRequestType_NewSecond = 3,
    }


}
